---
layout: default
title: Quick Start
---

This guide is meant to be a _very_ simple introduction to Buildr and its most basic concepts.  However, despite its basic level, we will still manage to cover most of the concepts you will ever need to be productive with Buildr.  We will leave out some important things (like "sub-projects":projects.html), and we will over-simplify some other concepts (such as "artifacts":artifacts.html).  Nevertheless, most Buildr projects never need to go beyond the techniques contained within these pages.

*No knowledge of Ruby is assumed.*  Buildr is designed to be a very intuitive, very easy-to-use tool.  You can create buildfiles which describe incredibly intricate projects, write custom tasks which do things far beyond Ant, and still never need to pick up more than a smattering of Ruby syntax.  With that said, if you do know Ruby, Buildr's DSL will seem very natural and welcoming, but Ruby expertise is by no means a prerequisite.  We do however assume that you have already "downloaded and installed":setup_guide.html Buildr and are ready to put the tool to good use.


h2(#first-project). Your First Project

Much like Maven, Buildr is oriented around projects and tasks.  You define your project in a concise, declarative fashion and most common tasks (such as compilation and testing) will be made available to you "at no extra charge".  Most of the project definition is contained within the _buildfile_ -- or _Buildfile_, if you're really in love with the Make convention -- a single file sitting at the root of your project.  A project definition does not need to be any more complicated than the following:

{% highlight ruby %}
define 'killer-app'
{% endhighlight %}

h3. Compilation

Of course, this isn't really giving Buildr much information.  What it can't learn from the buildfile, Buildr will learn by inspecting your directory structure.  Java sources are expected to exist within the @src/main/java/@ directory.  If Buildr finds these sources, it will automatically configure the compilation to source that directory, depositing the compilation results in the @target/classes/@ directory (all under the project directory of course).  We can run this compilation using the following command:

{% highlight sh %}
$ buildr compile
{% endhighlight %}

Information about the classpath and used dependencies is described "later on":#dependencies.

p(tip). By default, Buildr projects assume the Java language and the @src/main/java/@ source directory.  You can also have projects in the Scala or Groovy language (both languages support joint compilation with Java).  To use Scala, place your @.scala@ files in the @src/main/scala/@ directory and include the following invocation at the head of your buildfile: @require 'buildr/scala'@  Similarly, Groovy expects sources in the @src/main/groovy/@ directory and necessitates @require 'buildr/groovy'@ (see "languages":languages.html for more information).

The @compile@ task will also detect _any_ files which exist under the @src/main/resources/@ directory.  These resources are copied verbatim to the @target/resources/@ directory as part of the compilation task.  Buildr also performs some basic change detection to minimize compilation.  If your source files haven't changed since the last compile, then they will not be recompiled.

h3. Packaging

At some point, we're going to want to wrap up our classes and produce a single JAR file for distribution.  Buildr can certainly help us with this, but we are going to need to provide it with a little bit more information.  Specifically, we need to say the type of package to produce (e.g. @:jar@, @:war@, etc) as well as the current version of our project.  This information is placed within the buildfile:

{% highlight ruby %}
define 'killer-app' do
  project.version = '0.1.0'
  package :jar
end
{% endhighlight %}

The @project.version@ attribute can be any value you like.  Even non-numeric versions are perfectly acceptable (e.g. @'ikj-0.3.1-E'@).  This version, coupled with the packaging information will be used to generate a JAR file: @killer-app-0.1.0.jar@.  As would be expected, this file is placed within the @target/@ directory when the following command is run:

{% highlight sh %}
$ buildr package
{% endhighlight %}

The @package@ task depends upon the @compile@ task, so if a rebuild is necessary prior to the creation of the JAR, Buildr will see to it.

We can also chain tasks together in a single invocation.  For example, we may want to clean all of the old compilation results prior to recompiling and generating a packaged result:

{% highlight sh %}
$ buildr clean package
{% endhighlight %}

The @clean@ task simply removes the @target/@ directory, effectively wiping out any compilation results like class files or resources.

h3. Directory Structure

As you may have noticed, Buildr does have some default notions about what a project should look like and how it should be organized.  We think that these defaults are quite nice and make for a more navigable project.  However, we do understand that not all projects are exactly alike.  Buildr's "layouts":extending.html#layouts make it possible for any project to easily change these defaults.


h2(#dependencies). Dependencies

So far, we have seen how Buildr can automatically infer what amounts to dozens of lines of @build.xml@ contents, all based on a buildfile and a directory structure.  However, the best is yet to come.  Buildr also provides Maven-style dependency management (but without the known long loading times!).  In other words, you specify each dependent library using a string descriptor and Buildr figures out how to download and configure your classpath to use these libraries (the library descriptors are just a ruby list, therefore they are separated by comma (@,@)).  So that buildr knows where to download the libraries from you need to specify at least one remote repository.  For example, we can configure our project to reference the "Apache Commons CLI":http://commons.apache.org/cli/ library and download libraries from the ibiblio repository:

{% highlight ruby %}
repositories.remote << 'http://www.ibiblio.org/maven2/'
define 'killer-app' do
  project.version = '0.1.0'
  compile.with 'commons-cli:commons-cli:jar:1.2'
  package :jar
end
{% endhighlight %}

If you're familiar with Maven, then this sort of dependency declaration should look quite familiar.  Well, minus the verbose XML trapings.  The general format for an artifact descriptor is _groupId:artifactId:packageType:version_.  Any Maven artifacts included in this fashion will be retrieved from the "list of remote repositories":artifacts.html#repositories) and installed in your local repository at @~/.m2/repository/@.

p(tip). You can search the global repository of artifacts at sites like "MvnRepository":http://mvnrepository.com.  Simply enter the name of the library you are looking for, and the search should pull up the groupId, artifactId and a list of available versions. You could also try "mvnbrowser":http://www.mvnbrowser.com which lists the repositories that provide the artifact.

Unfortunately, not all libraries are quite as simple as Commons CLI.  In particular, many libraries, such as Apache Wicket, have dependencies of their own.  While we may be able to _compile_ against Apache Wicket without these extra libraries on our classpath, we cannot actually _run_ our application without its transitive dependencies. So that we don't have to track down all transitive dependencies and add them by hand to our buildfile, we can simply use the @transitive@ directive (this is how Maven behaves by default):

{% highlight ruby %}
repositories.remote << 'http://www.ibiblio.org/maven2/'
define 'killer-app' do
  project.version = '0.1.0'
  compile.with transitive('org.apache.wicket:wicket:jar:1.4-rc6')
  package :jar
end
{% endhighlight %}


As the @compile.with@ property accepts a full list of artifacts, making it possible to specify any number of dependencies is necessary.  Of course, such a long list of verbose string descriptors could get very tiresome and messy.  For this reason, it is conventional to assign each of your dependencies to a constant (e.g. @WICKET@) which is declared just above the project in the buildfile and passed to @compile.with@ in a clean, easy-to-read style:

{% highlight ruby %}
repositories.remote << 'http://www.ibiblio.org/maven2/'
WICKET = transitive('org.apache.wicket:wicket:jar:1.4-rc6')
SLF4J = 'org.slf4j:slf4j-jdk14:jar:1.5.8'
define 'killer-app' do
  project.version = '0.1.0'
  compile.with WICKET, SLF4J
  package :jar
end
{% endhighlight %}


Buildr also allows to download (and optionally extract) libraries from a specified url or load it from the filesystem. This is one area where Buildr's dependency management vastly excedes Maven's.  With Maven, you would have to install a dependency that's not available in a remote maven repository manually in your local repository.  Buildr's auto-magical download and extraction keeps the dependency definitions centralized within the buildfile, available to your entire team and automatically resolved as needed by the compilation tasks. More on this is also described on the "artifacts":artifacts.html page.


h2(#tasks). Testing

Buildr supports auto-magical integration with a number of mainstream testing frameworks.  For Java, this includes the ubiquitus JUnit4, as well as TestNG and a number of others.  Scala supports Specs and ScalaTest, while Groovy supports EasyB.  Configuration is as simple as placing our test sources in the appropriate directory.  In the case of java tests, this would be @src/test/java/@.  Once these tests are in place, we can run them using the @test@ task:

{% highlight sh %}
$ buildr test
{% endhighlight %}

When the @test@ task runs, it will ensure that your main sources are compiled, as well as the tests themselves.  In the case of JUnit4, test classes are auto-detected based on which base class they extend (@TestCase@).  These tests will be invoked using the special test classpath.  This classpath includes all of the dependencies passed to @compile.with@ along with the dependencies required for testing.  Thus, Buildr will actually go out and download JUnit 4.5 (if necessary) and place that JAR on the classpath in order to run your tests.  It is also possible to add artifacts specifically required for testing.  So, if your tests make use of the Commons Collections library, but your main sources do not, you can include that dependency only for the tests by using the @test.with@ property.  This functions identically to @compile.with@:

{% highlight ruby %}
define 'killer-app' do
  project.version = '0.1.0'
  compile.with 'commons-cli:commons-cli:jar:1.2'
  test.with 'commons-collections:commons-collections:jar:3.2'
  package :jar
end
{% endhighlight %}

Of course, not everyone _likes_ JUnit4.  As mentioned previously, Buildr supports a number of test frameworks.  It is possible to use TestNG instead of JUnit4 by setting the @test.using@ property to @:testng@:

{% highlight ruby %}
define 'killer-app' do
  project.version = '0.1.0'
  compile.with 'commons-cli:commons-cli:jar:1.2'
  test.with 'commons-collections:commons-collections:jar:3.2'
  test.using :testng
  package :jar
end
{% endhighlight %}


Note that only one test framework per-project may be used.  This may seem like an obvious restriction given that both frameworks introduced so far have used the same directory, but other frameworks such as Specs and EasyB do not follow the same convention.  In cases of ambiguity (for example, when tests are present in both @src/test/java/@ _and_ @src/spec/scala/@), only one test framework will be chosen, but this choice is not well-defined.  When in doubt, explicitly specify the test framework with the @test.using@ property.  This overrides Buildr's auto-detection and ensures sane behavior.

Other test frameworks are documented "here":testing.html and "here":languages.html.


h2(#custom-tasks). Custom Tasks

p(note). Ok, I lied: this section assumes a _little_ Ruby knowledge.  However, it's nothing that you couldn't pick up after spending 15 minutes with the core library documentation.

If there is one area in which Buildr excels, it is defining custom tasks.  This is something which is notoriously difficult in both Ant and Maven, often requiring separate Java plugins and mountains of code or just lots of xml simply to perform basic tasks.  For example, let's imagine that we wanted to define a @run@ task which would compile and run our "killer-app" project.  This is a simple matter of invoking the @java@ command against our main class:

{% highlight ruby %}
define 'killer-app' do
  project.version = '0.1.0'
  package :jar
  
  task :run => :compile do
    system 'java -cp target/classes org.apache.killer.Main'
  end
  
end
{% endhighlight %}

This code defines a new task, @run@, which depends upon the @compile@ task.  This task only performs a single operation: it invokes the @system@ method, passing the relevant command as a string.  Note that the @system@ method documentation may be found "here":http://www.ruby-doc.org/core/classes/Kernel.html#M005971.  Tasks use real Ruby (actually, the entire buildfile is real Ruby too), so if you are familiar with that language, then you should be right at home writing custom tasks in Buildr.  We can invoke this task in the following way:

{% highlight sh %}
$ buildr killer-app:run
{% endhighlight %}

We have to give the "@killer-app:@" prefix because we defined the @run@ task _within_ our project, rather than outside of the @define@ block.  If we would just define @run@ outside of the project, then we wouldn't have access to the @compile@ task (which is project-specific).

p(tip). If you want to be able to use just @run@, you can add @local_task :run@ outside your project definition (e.g. just before @define 'killer-app' do@).  The @local_task@ is also used for @compile@ and @test@ tasks, which are technically project-specific (think: instance methods) but can be invoked without the fully-qualified project name.


h2(#summary). Summary

As long as this guide was, we have barely even scratched the surface of Buildr's true power.  This was meant only to get you up and running as quickly as possible, exploiting some of Buildr's unique features to ease your build process.  For more comprehensive documentation, start reading about "projects in Buildr":projects.html and work your way from there.
